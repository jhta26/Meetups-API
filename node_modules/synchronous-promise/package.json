{
  "_args": [
    [
      {
        "raw": "synchronous-promise@^1.0.18",
        "scope": null,
        "escapedName": "synchronous-promise",
        "name": "synchronous-promise",
        "rawSpec": "^1.0.18",
        "spec": ">=1.0.18 <2.0.0",
        "type": "range"
      },
      "/Users/jasonhsu/reactNativeProject/MeetupsMap-API/node_modules/yup"
    ]
  ],
  "_from": "synchronous-promise@>=1.0.18 <2.0.0",
  "_id": "synchronous-promise@1.0.18",
  "_inCache": true,
  "_location": "/synchronous-promise",
  "_nodeVersion": "8.5.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/synchronous-promise-1.0.18.tgz_1507824691868_0.5214112931862473"
  },
  "_npmUser": {
    "name": "fluffynuts",
    "email": "davydm@gmail.com"
  },
  "_npmVersion": "5.3.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "synchronous-promise@^1.0.18",
    "scope": null,
    "escapedName": "synchronous-promise",
    "name": "synchronous-promise",
    "rawSpec": "^1.0.18",
    "spec": ">=1.0.18 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/yup"
  ],
  "_resolved": "https://registry.npmjs.org/synchronous-promise/-/synchronous-promise-1.0.18.tgz",
  "_shasum": "936e8763e6554088cdcf78dc64f7473b972fcefc",
  "_shrinkwrap": null,
  "_spec": "synchronous-promise@^1.0.18",
  "_where": "/Users/jasonhsu/reactNativeProject/MeetupsMap-API/node_modules/yup",
  "author": {
    "name": "Davyd McColl",
    "email": "davydm@gmail.com",
    "url": "https://github.com/fluffynuts"
  },
  "bugs": {
    "url": "https://github.com/fluffynuts/synchronous-promise/issues"
  },
  "dependencies": {},
  "description": "Synchronous Promise-like prototype to use in testing where you would have used an ES6 Promise",
  "devDependencies": {
    "browserify": "^14.1.0",
    "chai": "^3.5.0",
    "jslint": "^0.10.1",
    "mkdirp": "^0.5.1",
    "mocha": "^2.5.3",
    "mocha-yar": "^1.0.10",
    "nodemon": "^1.10.2",
    "npm-run-all": "^2.3.0",
    "run-sequence": "^1.2.2"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-UqMAK6BBBXu8qaDI5omlyV9iDpM9nQfgthaBOK0nlfXnMgiuOBv+meWG73CGeCCFRhOOOa2e4rvqYzfynzy5zg==",
    "shasum": "936e8763e6554088cdcf78dc64f7473b972fcefc",
    "tarball": "https://registry.npmjs.org/synchronous-promise/-/synchronous-promise-1.0.18.tgz"
  },
  "gitHead": "697e306e74b53674e6da8376a113b905923e7db3",
  "homepage": "https://github.com/fluffynuts/synchronous-promise#readme",
  "license": "BSD-3-Clause",
  "main": "index.js",
  "maintainers": [
    {
      "name": "fluffynuts",
      "email": "davydm@gmail.com"
    }
  ],
  "name": "synchronous-promise",
  "optionalDependencies": {},
  "readme": "# synchronous-promise\r\nTL;DR: A prototypical animal which looks like an A+ Promise but doesn't defer\r\nimmediately, so can run synchronously, for testing. Technically, this makes it\r\n*not* A+ compliant, since part of the A+ spec is that resolution be asynchronous.\r\n\r\nThis means that I unfortunately can't run the official tests at [https://github.com/promises-aplus/promises-tests](https://github.com/promises-aplus/promises-tests). As such, I rely on issue reports from users and welcome contributions.\r\n\r\n### Why?\r\nThe standard ES6 Promise (and any others which *are* A+ compliant) push the promise logic to the background\r\nimmediately, departing from the mechanisms employed in years past by promise\r\nimplementations in libraries such as jQuery and Q.\r\n\r\nThis is a good thing -- for production code. But it can make testing more\r\nconvoluted than it really needs to be.\r\n\r\nOften, in a test, we're stubbing out a function which would return a promise\r\n(eg http call, show a modal dialog requiring user interaction) with a promise\r\nthat resolves immediately, eg (using, mocha/sinon/chai):\r\n\r\n```javascript\r\ndescribe('the thing', () => {\r\n  it('will do some stuff', () => {\r\n    // Arrange\r\n    const asyncLibraryFake = {\r\n      someMethod: sinon.stub().returns(Promise.resolve('happy value!'))\r\n    },\r\n    sut = createSystemUnderTestWith(asyncLibraryFake);\r\n    // Act\r\n    sut.doSomethingInteresting();\r\n    // Assert\r\n    //  [*]\r\n  })\r\n});\r\n```\r\n\r\n[*] Ideally, we'd just have assertions here, but the code above has backgrounded,\r\nso we're not going to get our expected results unless we employ async testing\r\nstrategies ourselves.\r\n\r\nOne strategy would be to return the promise from\r\n  asyncLibraryFake.someMethod\r\nfrom the\r\n  doSomethingInteresting\r\nfunction and perform our asserts in there: \r\n  \r\n```javascript\r\ndescribe('the thing', () => {\r\n  it('will do some stuff', done => {\r\n    // Arrange\r\n    const asyncLibraryFake = {\r\n      someMethod: sinon.stub().returns(Promise.resolve('happy value!'))\r\n    },\r\n    sut = createSystemUnderTestWith(asyncLibraryFake);\r\n    // Act\r\n    sut.doSomethingInteresting().then(() => {\r\n      // Assert\r\n      done()\r\n    });\r\n  })\r\n});\r\n```\r\n***And there's nothing wrong with this strategy.***\r\n\r\nI need to put that out there before anyone takes offense or thinks that I'm suggesting \r\nthat they're \"doing it wrong\".\r\nIf you're doing this (or something very similar), great; `async/await`, if available, \r\ncan make this code quite clean and linear too.\r\n\r\nHowever, when we're working on more complex interactions, eg when we're not\r\ntesting the final result of a promise chain, but rather testing a side-effect\r\nat some step during that promise chain, this can become more effort to test\r\n(and, imo, make your testing more unclear).\r\n\r\nMany moons ago, using, for example, Q, we could create a deferred object with\r\n`Q.defer()` and then resolve or reject ith with `deferred.resolve()` and\r\n`deferred.reject()`. Since there was no initial backgrounding, we could set\r\nup a test with an unresolved promise, make some pre-assertions, then resolve\r\nand make assertions about \"after resolution\" state, without making our tests\r\nasync at all. It made testing a little easier (imo) and the idea has been\r\npropagated into frameworks like `angular-mocks`\r\n\r\n### Usage\r\n\r\nSynchronousPromise looks (from the outside) a lot like an ES6 promise. We construct\r\nthe same:\r\n\r\n```javascript\r\nvar promise = new SynchronousPromise((resolve, reject) => {\r\n  if (Math.random() < 0.1) {\r\n    reject('unlucky!');\r\n  } else {\r\n    resolve('lucky!');\r\n  }\r\n});\r\n```\r\n\r\nThey can, of course, be chained:\r\n\r\n```javascript\r\nvar initial = new SynchronousPromise((resolve, reject) => {\r\n  resolve('happy!');\r\n});\r\ninitial.then(message => {\r\n  console.log(message);\r\n})\r\n```\r\n\r\nAnd have error handling, either from the basic A+ spec:\r\n   \r\n```javascript\r\ninitial.then(message => {\r\n  console.log(message);\r\n}, error => {\r\n  console.error(error);\r\n});\r\n```\r\n\r\nOr using the more familiar `catch()`:\r\n\r\n```javascript\r\ninitial.then(message => {\r\n  console.log(message);\r\n}).catch(error => {\r\n  console.error(error);\r\n})\r\n```\r\n\r\n`.catch()` starts a new promise chain, so you can pick up with new logic\r\nif you want to. `.then()` can deal with returning raw values or promises\r\n(as per A+)\r\n\r\n### Statics\r\n`.all()`, `.resolve()` and `.reject()` are available on the `SynchronousPromise`\r\nobject itself:\r\n\r\n```javascript\r\nSynchronousPromise.all([p1, p2]).then(results => {\r\n  // results is an array of results from all promises\r\n}).catch(err => {\r\n  // err is any single error thrown by a promise in the array\r\n});\r\n\r\nSynchronousPromise.resolve('foo');  // creates an already-resolved promise\r\n\r\nSynchronousPromise.reject('bar'); // creats an already-rejected promise\r\n```\r\n\r\n(`race()` isn't because I haven't determined a good strategy for that yet, \r\nconsidering the synchronous design goal -- but it's\r\nunlikely you'll need `race()` from a test).\r\n\r\n### Extras\r\n`SynchronousPromise` also provides two extra functions to make testing a little\r\neasier:\r\n\r\n#### Static methods\r\nThe `unresolved()` method returns a new, unresolved `SynchronousPromise` with\r\nthe constructor-function-provided `resolve` and `reject` functions attached as properties.\r\nUse this when you have no intention of resolving or rejecting the promise or when you\r\nwant to resolve or reject at some later date.\r\n\r\n```javascript\r\nvar\r\n  resolvedValue,\r\n  rejectedValue,\r\n  promise = SynchronousPromise.unresolved().then(function(data) {\r\n    resolved = data;\r\n  }).catch(function(data) {\r\n    rejected = data;\r\n  });\r\n  // at this point, resolved and rejected are both undefined\r\n\r\n  // ... some time later ...\r\n  if (Math.random() > 0.5) {\r\n    promise.resolve(\"yay\");\r\n    // now resolvedValue is \"yay\" and rejectedValue is still undefined\r\n  } else {\r\n    promise.reject(\"boo\");\r\n    // now rejectedValue is \"boo\" and resolvedValue is still undefined\r\n  }\r\n```\r\n\r\n#### Instance methods\r\n\r\n`pause()` pauses the promise chain at the point at which it is called:\r\n\r\n```javascript\r\nSynchronousPromise.resolve('abc').then(data => {\r\n  // this will be run\r\n  return '123';\r\n}).pause().then(data2 => {\r\n  // we don't get here without resuming\r\n});\r\n```\r\n\r\nand `resume()` resumes operations:\r\n\r\n```javascript\r\nvar\r\n  promise = SynchronousPromise.resolve('123').pause(),\r\n  captured = null;\r\npromise.then(data => {\r\n  captured = data;\r\n});\r\n\r\nexpect(data).to.be.null;   // because we paused...\r\npromise.resume();\r\nexpect(data).to.equal('123'); // because we resumed...\r\n```\r\n\r\nYou can use `pause()` and `resume()` to test the state of your system under\r\ntest at defined points in a series of promise chains\r\n\r\n### ES5\r\nSynchronousPromise is purposefully written with prototypical, ES5 syntax so you\r\ncan use it from ES5 if you like. Use the `synchronous-promise.js` file from the \r\n`dist` folder if you'd like to include it in a browser environment (eg karma).\r\n\r\n## Typescript\r\nThe `synchronous-promise` package includes an `index.d.ts`. To install, run:\r\n```\r\ntypings install npm:synchronous-promise --save\r\n```\r\n*On any modern TypeScript (v2+), you shouldn't need to do this.*\r\n\r\n### Production code\r\nThe main aim of SynchronousPromise is to facilitate easier testing. That being\r\nsaid, it appears to conform to expected `Promise` behaviour, barring the\r\nalways-backgrounded behaviour. One might be tempted to just use it everywhere.\r\n\r\n**However**: I'd highly recommend using *any* of the more venerable promise implementations\r\ninstead of SynchronousPromise in your production code -- preferably the vanilla\r\nES6 Promise, where possible (or the shim, where you're in ES5). Or Q.\r\nOr jQUery.Deferred(), Bluebird or any of the implementations at [https://promisesaplus.com/implementations](https://promisesaplus.com/implementations). \r\n\r\nBasically, this seems to work quite well for testing and\r\nI've tried to implement every behaviour I'd expect from a promise -- but I'm\r\npretty sure that a native `Promise` will be better for production code any day. \r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/fluffynuts/synchronous-promise.git"
  },
  "scripts": {
    "autolint": "nodemon -q -x \"run-s -s lint\"",
    "autotest": "nodemon -q -x \"run-s -s autotest-once\"",
    "autotest-once": "mocha *.spec.js --reporter mocha-yar",
    "dist": "browserify browser.js -o dist/synchronous-promise.js",
    "lint": "jslint index.js",
    "preautotest-once": "node -e \"console.log('Tests started: ', new Date());\"",
    "predist": "mkdirp dist",
    "prepublish": "run-s -s test dist",
    "pretest": "run-s lint",
    "test": "mocha index.spec.js"
  },
  "version": "1.0.18"
}
